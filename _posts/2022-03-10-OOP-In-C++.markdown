**OOP in C++**
- An instance of a class is called an *object*

**Inheritance Basics**
- Inheritance should be used to model 'is-a' relationships
- For example, consider a Animal and a Dog (which is an animal).
- Used to prevent code duplication/hide functionality
#Example#

- We say that the Animal class is *derived* from the Animal class.
- A derived class inherits all attributes from the class(es) it derives from.
- In our example, a dog object will have a name (inherited from the Animal class), and a breed (from the Dog class).
- #example with two unrelated classes deriving from the same one (cat and dog)#

**Constructing a Derived Object**
*key point: a derived object can be thought of as being 'part base/part derived'* (just another way to think of the 'is-a' model)
- Construction of a derived object is done in phases. (base->down to the derived)
#example with constructors for base/derived#
- You cannot initialize inherited member variables in the member initializer list of the constructor of a derived class. This is because if the inherited var was const, we might end up redefining it in the derived constructor which is not allowed! Instead you should initialized inherited members using a constructor from the base class
#example where derived constructor calls base constructor in memb-initi-list#

**Calling Inherited Functions**
- When a function is called on a derived object, the compiler will check if the function exists in the derived class. If not, it will look up the inheritance chain for a definition, and will use the first one found
- Sometimes need to use scope operator :: to prevent infinite loops
- - 

**Destruction**
- The order of destruction is the reverse of construction (i.e derived -> up to base)

**Access Specifiers**

**Multiple Inheritance**
- Avoid it wherever possible.



**Polymorphism**
- In the general case, polymorphism means *representing multiple concepts with a single intterface*.
- Polymorphism can be further categorised into:

1) **Static (Compile-Time) Polymorphism**

    **Ad-Hoc Polymorphism** (a.k.a function/operator overloading) *Where a function behaves differently depending on its arguments/types*
    - This is also known as function overloading (and operator overloading in C++)
    - Technically unrelated to OOP.
    - e.g. consider the expression a+b... (how it is evaluated depends on the types of a and b!)

   **Parametric Polymorphism**
  *Where a function behaves identically without depending on the type*
  - In C++, this refers to the use of templates (Generics in Java)
  - Again, not really what we mean by polymorphism in the context of OOP.

2) **Dynamic (Run-Time) Polymorphism**
   - This is what people typically mean when they refer to polymorphism in OOP
  
  
**Pointers/References & Inheritance**
- C++ allows us to set a base pointer/reference to a derived object. However doing so result in unexpected output
#Example where a base pointer pointing to a derived object calls the base function rather than the derived one
- It turns out that the base pointer can only see the 'base part' (remember a derived object is part base/part derived)

**Why would we do this?**
- might want to store a number of objects in a container, to iterate through...
- Using base pointers allows us to use a single container, else would need a separate one for each derived class
#easy example using animals and 'speak'
- In order to use the correct implementation of speak, we utilise polymorphism via *virtual* functions


**Virtual Functions
- A virtual function allows us to override definitions from a base class.
- When a function specified as virtual is called, the compiler looks for the most derived version of the function.

#This virtual call mechanism is what allows us to call animal->speak for every object in the vector in the above example
*GOTCHA: Dont call virtual functions from a constructor (remember the order in which parts of a derived object are constructed!)*
- The functions must have the same signature. 
- If you specify a function as override, the compiler will throw an error if that function does not override anything (USE THIS!)
- If you specify a function(class) as final, the compiler won't allow you to override(inhert) from that function(class).

**Why Shouldn't We Declare All Functions Virtual?**
- Inefficient. 
